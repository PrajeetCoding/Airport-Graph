Leading Question: Can we create a reliable way of finding the shortest distance/path between two airports? 

For this final project, our goal was to create a program that could find the shortest distances between two airports and demonstrate the importance of using Dijkstra's algorithm instead of a regular BFS traversal to do so.  We then set the additional goal of finding important airports by using the betweenness centrality algorithm to calculate the centrality of each airport and then comparing them.   

Using a BFS traversal and Dijkstra's algorithm, we were able to create a program that takes two airport inputs and outputs their distances using both algorithms.  We output both results for comparison.  We tested these functions by making sure they handled empty/null cases where no path exists, and then by making sure that Dijkstra's algorithm consistently output a distance less than or equal to the corresponding BFS traversal (we picked 30 randomly generated paths). An example of the output of Dijkstra’s algorithm vs BFS traversal can be seen in the file “Dijkstra’s algorithm vs BFS.PNG”. 

Using the betweenness centrality algorithm we were able to create a program that was able to measure the centrality of each airport, but since the algorithm is so slow with large datasets, we modified it to use a random sample of data in order to approximate the centrality of an airport.  To make sure there is a version of the function with a reasonable runtime, we created a method of using betweenness centrality to compare two airports and return the more important airport (or the one with the highest measure of centrality).  We tested this by making sure the betweenness centrality of an airport with no paths connecting to it was zero, and that an airport that had all paths running through it had a higher centrality. Furthermore, we tried testing centrality calculations for two airports with lots of edges. We made sure that the airport that was more connected to the rest of the graph had the higher centrality. An example of the output of calculating betweenness centrality can be found in the file “Betweenness Centrality.PNG”. 

For testing in general we created multiple difficulty levels of tests to test that we were seeing the same behavior with more complex/random datasets.  We also had tests that tested the underlying graph structure, csv parser, and distance functions. For the graph class, we even created a test case that utilized the full dataset. 

With respect to our original leading question, we were able to answer this by implementing Dijkstra's algorithm to traverse the graph and find the shortest distance between nodes in it. We consistently found the shortest path with multiple different pairs of randomly selected airports.  To demonstrate the importance of using Dijkstra's algorithm, we compared it with using a regular breadth first search and found that Dijkstra's algorithm either found a shorter path or a path of the same length.  One of the things we hypothesized during the project was that BFS always found a path with less or an equal number of nodes in comparison to Dijkstra’s. This was something discovered and confirmed after finishing the project. Throughout the project, we ran into superficial difficulties with the csv parser, graph class, and traversals class that only required simple logic checks and minor tweaks to the code, but when implementing betweenness centrality we ran into major issues with runtime since the numbers of nodes and edges were so large (betweenness centrality takes O(V^3) to calculate, and there are ~7600-7700 nodes in the graph).  To mitigate this problem, we decided to use a smaller random sample size, which is not as accurate but will provide a reasonable approximation (accurate enough to compare two airports) within a reasonable amount of time.  We also created the option to compare the centralities of two airports (to determine which one is more important) as an alternative to finding the top N airports.
